# Technical Implementation Doc (TID) — Крестики‑нолики с Telegram‑уведомлениями

## 1. Обзор
- Цель: веб‑игра 3×3 против компьютера. При победе — 5‑значный промокод, отображение на UI, отправка в Telegram; при поражении — уведомление в Telegram и предложение сыграть снова.
- Пользователь: женщины 25–40 лет; приоритет мягкой палитры, плавных анимаций, закруглений, минимализма.

## 2. Архитектура
- Frontend: React (Vite/CRA), SPA. Минимальный backend-прокси для Telegram.
- Backend: Node.js/serverless endpoint `/send` для проксирования Telegram Bot API.
- Бот: Telegraf (по данным/гайдам из telegraf MCP) с polling/webhook; хранит связь username → chat_id после `/start`.
- Поток (win): UI запрашивает username → `POST /send {status:'win', code, username}` → backend находит chat_id → Telegram Bot API `sendMessage`.
- Поток (lose): UI → `POST /send {status:'lose', username?}` → backend → Telegram.
- Предупреждение: пользователю нужно сначала нажать `/start` в боте, чтобы бот получил его chat_id; без этого отправка не сработает.

## 3. UI/UX
- Палитра: пастельные розово-бежевые тона; шрифт Inter/Rubik/Nunito; закруглённые карточки/кнопки; плавные hover/press анимации.
- Экраны: приветствие → игровое поле → состояния Win/Lose/Draw с CTA «Сыграть ещё».
- Компоненты: поле 3×3, ячейка, статусная панель (ход, состояние), модалки/тосы для победы/поражения, кнопка сброса.

## 4. Состояния и данные
- Структура состояния (пример):
  - `board: Array<9>` (значения `'X' | 'O' | null`)
  - `currentPlayer: 'X' | 'O'`
  - `status: 'idle' | 'playing' | 'win' | 'lose' | 'draw'`
  - `promoCode?: string`
  - `username?: string`
  - `isSending: boolean`, `error?: string`
- Хранение промокода только в памяти сессии.

## 5. Игровая логика
- Ход пользователя: ставит `X` в пустую клетку → проверка завершения.
- Ход компьютера: простая стратегия (рандом из пустых; допускается улучшенный выбор для блокировки/выигрыша).
- Определение завершения: проверка 8 линий выигрыша; если нет ходов — ничья.
- Победа пользователя: генерируем промокод (A–Z, 0–9, длина 5), показываем UI, запрашиваем username (например, `@nickname` без `@`), валидируем непустое значение, затем `/send {status:'win', code, username}`.
- Если username не указан — блокируем отправку, но показываем промокод локально.
- Проигрыш: статус lose, `/send {status:'lose', username?}` (можно пустым, уведомление идёт без персонализации).
- Ничья: статус draw, UI кнопка «Играть снова» (без запроса в Telegram).
- Сброс: очистка состояния, новый раунд.

## 6. Генерация промокода
- Алфавит: `A–Z0–9`, длина 5, случайный, без хранения в БД.
- Генерация на клиенте перед отправкой победы.

## 7. API
- `POST /send`
  - Body: `{ status: 'win' | 'lose', code?: string, username?: string }`
  - Ответ: `{ ok: true }` или `{ ok: false, error, reason?: 'chat_not_found' }`
  - Валидация: статус обязателен; `code` и `username` обязательны при `win`.
- Telegram Bot API: `sendMessage` (сервер хранит `BOT_TOKEN`; chat_id определяется по username).

## 8. Backend
- Node.js (Express или serverless handler) + Telegraf (по данным из telegraf MCP).
- Логика:
  - Читает `BOT_TOKEN` из env.
  - Telegraf обрабатывает `/start`, сохраняя пару `{username, chat_id}` в in-memory map (опционально с TTL) или KV/DB (если доступно).
  - `/send` при `win`: ищет chat_id по username; если нет — возвращает `chat_not_found`.
  - Формирует текст: `Победа! Промокод выдан: {code}` или `Проигрыш`.
  - Делает `fetch`/axios к `https://api.telegram.org/bot${BOT_TOKEN}/sendMessage` с найденным chat_id.
  - Обрабатывает ошибки (лог, 4xx/5xx).
- Требование: пользователь должен запустить `/start` в боте заранее, чтобы chat_id был сохранён.
- Без постоянного хранения состояния/БД (если нет KV) — допустимо in-memory, но тогда после рестарта бот попросит пользователя повторно нажать `/start`.

## 9. Безопасность
- Токен Telegram только на сервере/env.
- CORS: ограничить origin фронтендом.
- Rate limit на `/send` (минимальный, чтобы избежать спама).
- Валидация входных данных на сервере.

## 10. Ошибки и UX деградации
- При ошибке отправки: показать toast/alert «Ошибка отправки уведомления»; если причина `chat_not_found` — текст «Сначала нажмите /start в боте, чтобы мы узнали ваш чат».
- Отправка в Telegram асинхронно; UI не ждёт, но отображает спиннер при `isSending`.

## 11. Доступность и i18n
- Управление с клавиатуры (фокус на клетках/кнопках).
- ARIA для клеток (`role="button"`, `aria-pressed`), статусов (`aria-live`).
- Тексты на русском; структура позволяет вынести строки в объект для будущей локализации.

## 12. Производительность
- Малый бандл; использовать code-splitting по экранам опционально.
- Анимации через CSS transitions; избегать тяжёлых layout-thrashing эффектов.
- Ответ хода ИИ ≤150 мс (сетевой вызов не обязателен).

## 13. Сборка и инструменты
- Frontend: Vite + React + TypeScript (предпочтительно), ESLint/Prettier.
- Backend: Vercel/Netlify function или мини-сервер Express.
- Деплой: фронт на Vercel/Netlify; backend — тот же провайдер как serverless.

## 14. Тестирование
- Юнит: функции генерации кода, проверка победы/ничьей.
- Интеграция: цикл ходов, отправка `/send` с моками.
- E2E (опционально): Cypress/Playwright — сценарий победы/проигрыша.

## 15. Конфигурация и окружения
- ENV (server): `BOT_TOKEN`, `ALLOWED_ORIGIN`; опционально `WEBHOOK_URL`/`PORT` для Telegraf, хранилище для username→chat_id (если доступно).
- ENV (client): `VITE_API_URL` для вызова `/send`.
- Build-time режимы: `development`, `production`.

## 16. Открытые моменты (если понадобится уточнить)
- Конкретный хостинг (Vercel/Netlify/Render).
- Сложность логики ИИ (рандом или блокировка выигрыша игрока).
- Нужен ли лог событий/метрик.


